package rocks.inspectit.oce.core.config.filebased;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import lombok.val;
import org.springframework.core.env.EnumerablePropertySource;
import org.springframework.core.env.MutablePropertySources;
import org.springframework.core.env.PropertiesPropertySource;
import org.springframework.core.env.PropertySource;
import org.springframework.core.io.FileSystemResource;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Special Properties source which adds all .properties and .yml/.yaml files form a directory as property sources.
 * No subdirectories are parsed!
 * The files are parsed in alphabetical order where the configuration from the first found file wins.
 * This is done by adding the DirectoryPropertySource as marker which is followed by all contained files as PropertySources.
 * {@link org.springframework.core.env.CompositePropertySource} was not used as this causes issues with the overwriting of Lists.
 *
 * @author Jonas Kunz
 */
@Slf4j
public class DirectoryPropertySource extends EnumerablePropertySource<Void> {


    private static final List<String> PROPERTIES_ENDINGS = Arrays.asList(".properties");
    private static final List<String> YAML_ENDINGS = Arrays.asList(".yml", ".yaml");

    @Getter
    private Path rootDir;

    /**
     * Creates a new DirectoryPropertySource.
     * It has to be added to a container manually and then {@link #reload(MutablePropertySources)} has to called to load the actual configurations.
     *
     * @param name    the name of this source
     * @param rootDir the root directory to parse
     */
    public DirectoryPropertySource(String name, Path rootDir) {
        super(name);
        this.rootDir = rootDir;
    }

    /**
     * Removes all previously loaded {@link PropertySource}s generated by this {@link DirectoryPropertySource} in the given container.
     * Afterwards parses the directory and generated a {@link PropertySource} for each found config file, which is added after this {@link DirectoryPropertySource} to the container.
     *
     * @param container the container to update
     */
    public void reload(MutablePropertySources container) {
        removeChildrenFromContainer(container);

        List<ChildFilePropertySource> childSources = loadContentsToPropertySources();

        PropertySource<?> previous = this;
        for (val pps : childSources) {
            container.addAfter(previous.getName(), pps);
            previous = pps;
        }
    }

    private void removeChildrenFromContainer(MutablePropertySources container) {
        Collection<ChildFilePropertySource> childSources = container.stream()
                .filter(ps -> ps instanceof ChildFilePropertySource)
                .map(ps -> (ChildFilePropertySource) ps)
                .filter(ps -> ps.getOwner() == this)
                .collect(Collectors.toList());
        for (PropertySource<?> ps : childSources) {
            container.remove(ps.getName());
        }
    }

    private List<ChildFilePropertySource> loadContentsToPropertySources() {
        Stream<Path> files;
        try {
            files = Files.list(rootDir).filter(p -> !p.toFile().isDirectory());
        } catch (IOException e) {
            logger.error("Unable to access config dir", e);
            return Collections.emptyList();
        }
        //alphabetical order, last loaded file wins
        List<ChildFilePropertySource> fileSources = new ArrayList<>();
        files.sorted(Comparator.naturalOrder()).forEachOrdered(file -> {
            if (doesFileHaveEnding(file, PROPERTIES_ENDINGS)) {
                loadPropertiesFile(file).ifPresent(fileSources::add);
            } else if (doesFileHaveEnding(file, YAML_ENDINGS)) {
                fileSources.add(loadYamlFile(file));
            }
        });
        return fileSources;
    }

    private Optional<ChildFilePropertySource> loadPropertiesFile(Path file) {
        try {
            String name = getCombinedName(file);
            return Optional.of(new ChildFilePropertySource(name, PropertyFileUtils.readPropertyFiles(new FileSystemResource(file))));
        } catch (Exception e) {
            logger.error("Unable to load config file!", e);
            return Optional.empty();
        }
    }

    private ChildFilePropertySource loadYamlFile(Path file) {
        String name = getCombinedName(file);
        return new ChildFilePropertySource(name, PropertyFileUtils.readYamlFiles(new FileSystemResource(file)));
    }


    private static boolean doesFileHaveEnding(Path path, Collection<String> allowedEndings) {
        String filename = path.getFileName().toString().toLowerCase();
        return allowedEndings.stream().anyMatch(ending -> filename.endsWith(ending));
    }

    private String getCombinedName(Path file) {
        return getName() + "/" + file.getFileName();
    }


    @Override
    public String[] getPropertyNames() {
        return new String[0];
    }

    @Override
    public Object getProperty(String name) {
        return null;
    }

    /**
     * Nested class representing a single loaded configuration file
     */
    private class ChildFilePropertySource extends PropertiesPropertySource {

        public ChildFilePropertySource(String name, Properties source) {
            super(name, source);
        }

        /**
         * @return the {@link DirectoryPropertySource} to which this file belongs
         */
        DirectoryPropertySource getOwner() {
            return DirectoryPropertySource.this;
        }
    }
}
