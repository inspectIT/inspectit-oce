package rocks.inspectit.oce.core.rocks.inspectit.oce.core.config;

import lombok.Getter;
import lombok.experimental.var;
import lombok.extern.slf4j.Slf4j;
import lombok.val;
import org.springframework.core.env.EnumerablePropertySource;
import org.springframework.core.env.MutablePropertySources;
import org.springframework.core.env.PropertiesPropertySource;
import org.springframework.core.env.PropertySource;
import org.springframework.core.io.FileSystemResource;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.stream.Stream;

/**
 * Special Properties source which adds all .properties and .yml/.yaml files form a directory as property sources.
 * No subdirectories are parsed!
 * The files are parsed in alphabetical order where the configuration from the first found file wins.
 * This is done by adding the DirectoryPropertySource as marker which is followed by all contained files as PropertySources.
 * {@link org.springframework.core.env.CompositePropertySource} was not used as this causes issues with the overwriting of Lists.
 *
 * @author Jonas Kunz
 */
@Slf4j
public class DirectoryPropertySource extends EnumerablePropertySource<Void> {


    private static final List<String> PROPERTIES_ENDINGS = Arrays.asList(".properties");
    private static final List<String> YAML_ENDINGS = Arrays.asList(".yml", ".yaml");

    @Getter
    private Path rootDir;

    /**
     * stores all contained PropertySources (=one for each contained file)
     */
    private final List<PropertySource<?>> ownedFilePropertySources = new ArrayList<>();

    private MutablePropertySources container;

    /**
     * Factory method.
     * Creates a DirectoryPropertySource and places it as last source in the given container.
     * @param name the name of the DirectoryPropertySource to create. This is used as basename for the PropertySources generated for each contained file.
     * @param rootDir the directory to parse for config files
     * @param container the container to append the PropertySources to
     * @return
     */
    public static DirectoryPropertySource addLast(String name, Path rootDir, MutablePropertySources container) {
        val dps = new DirectoryPropertySource(name,rootDir,container);
        container.addLast(dps);
        dps.reload();
        return dps;
    }

    private DirectoryPropertySource(String name, Path rootDir, MutablePropertySources container) {
        super(name);
        this.rootDir = rootDir;
        this.container = container;
    }

    /**
     * Removes all previously loaded {@link PropertySource}s generated by this {@link DirectoryPropertySource} .
     * Afterwards parses the directory and generated a {@link PropertySource} for each found config file, which is added after this {@link DirectoryPropertySource} to the container.
     */
    public void reload() {
        for(PropertySource<?> ps : ownedFilePropertySources) {
            container.remove(ps.getName());
        }
        ownedFilePropertySources.clear();

        if (loadContentsToPropertySources()) return;

        PropertySource<?> previous = this;
        for(var pps : ownedFilePropertySources) {
            container.addAfter(previous.getName(), pps);
            previous = pps;
        }
    }

    private boolean loadContentsToPropertySources() {
        Stream<Path> files;
        try {
            files = Files.list(rootDir).filter(p -> !p.toFile().isDirectory());
        } catch (IOException e) {
            logger.error("Unable to access config dir", e);
            return true;
        }
        //alphabetical order, last loaded file wins
        files.sorted(Comparator.naturalOrder()).forEachOrdered(file -> {
            if (doesFileHaveEnding(file, PROPERTIES_ENDINGS)) {
                loadPropertiesFile(file);
            } else if (doesFileHaveEnding(file, YAML_ENDINGS)) {
                loadYamlFile(file);
            }
        });
        return false;
    }

    private void loadPropertiesFile(Path file) {
        try {
            InputStream fin = Files.newInputStream(file);
            Properties props = new Properties();
            props.load(fin);
            fin.close();

            String name = getCombinedName(file);
            PropertiesPropertySource pps = new PropertiesPropertySource(name, props);
            ownedFilePropertySources.add(pps);
        } catch (Exception e) {
            logger.error("Unable to load config file!", e);
        }
    }

    private void loadYamlFile(Path file) {
        String name = getCombinedName(file);
        PropertiesPropertySource pps = new PropertiesPropertySource(name, ConfigurationUtils.readYamlsAsProperties(new FileSystemResource(file)));
        ownedFilePropertySources.add(pps);
    }


    private static boolean doesFileHaveEnding(Path path, Collection<String> allowedEndings) {
        String filename = path.getFileName().toString().toLowerCase();
        return allowedEndings.stream().anyMatch(ending -> filename.endsWith(ending));
    }

    private String getCombinedName(Path file) {
        return getName() + "/" + file.getFileName();
    }


    @Override
    public String[] getPropertyNames() {
        return new String[0];
    }

    @Override
    public Object getProperty(String name) {
        return null;
    }
}
